#include <iostream>
#include <set>
#include <cmath>
#include <random>
#include <algorithm>    // swap()
#include <vector>
#include <string>

using namespace std;
int Maxlba;
int Kpp;   // Key Per Page

// Data Structure
class Key
{
public:
    int begin, end, level;  // lba begin & end that the key take care of
    Key(int x, int y, int l) :
        begin(x),
        end(y),
        level(l) {}
    Key(int x, int y) : begin(x), end(y) {}
    Key() : begin(0), end(0), level(0) {}

    bool operator<(const Key& other) const {
        if (level != other.level) return level < other.level;
        if (begin != other.begin) return begin < other.begin;
        return end < other.end;
    }

    bool operator==(const Key& other) const {
        return begin == other.begin && end == other.end && level == other.level;
    }
};
// cout overload
ostream& operator << (ostream &out, const Key &i)
{
    cout << "(" << i.begin << "," << i.end << ")" << "-" << i.level;
    return out;
}
// ======================================================================
class Record
{
public:
    int begin, end, key_num;
    Record(int x, int y, int z) :
        begin(x),
        end(y),
        key_num(z) {}
};
ostream& operator << (ostream &out, const Record &i)
{
    cout << "(" << i.begin << "," << i.end << ")" << " |s: " << (i.end - i.begin + 1) << " |k: " << i.key_num ;
    return out;
}

// ======================================================================
// Functions
void tree_constructor(int maxlba, set<Key> &tree);  // given maxlba id, push keys into set tree
void traverse(set<Key> x);  // traverse and print x
void key2root(int x, int y, int l, set<Key> &k);   // given Key(x,y), push all its upper keys(<= level2) into set k
pair<int, int> cmd_gen(int size);  // given size, return valid data id by the chunk size
int rand_gen(int min, int max); // pure rand_gen of range [min, max]
pair<int, int> find_min_max(vector<int> row);   // given a row, return <min, max> value in a pair

void tree_constructor(int maxlba, set<Key> &tree)
{
    int N = ceil(log2(Maxlba+1) / log2(Kpp)) + 1;   // total level num
    // build from level 1 to level N
    for(int i = 1; i <= N; i ++) {
        // size: #lba this key covered
        // offset: offset for begin & end of one key
        int size = (i == N) ?1 :(pow(Kpp, N - i));
        int offset = size - 1;
        for(int j = 0; j <= maxlba; j += size) {
            tree.insert(Key(j, j+offset, i));
        }
    }
}
void traverse(set<Key> x)
{
    cout << "size: " << x.size() << endl;
    int N = ceil(log2(Maxlba+1) / log2(Kpp)) + 1;   // total level num

    for(auto i: x) {
        if(i.level == N) break;
        cout << i.begin << "," << i.end << " -" << i.level << endl;
    }
    cout << "---\n";
}
void key2root(int x, int y, int l, set<Key> &k)
{
    if(x < 0 || y < 0 || l < 0 || x > Maxlba|| y > Maxlba || l == 1) return;
    else {
        k.insert(Key(x, y, l));
        // buttom up recursive
        // calculate parent's key id
        int N = ceil(log2(Maxlba+1) / log2(Kpp)) + 1;   // total level num
        int p_size = pow(Kpp, N - (l - 1)), p_offset = p_size - 1;
        int p_x = x / p_size;
        key2root(p_x * p_size, p_x * p_size + p_offset, l - 1, k);
        return;
    }
    return;
}
pair<int, int> cmd_gen(int size)
{
    int a, b = -1;
    while(b == -1) {
        a = rand_gen(0, Maxlba);   // gen a valid data id
        if( (a + size - 1) <= Maxlba) {
            b = a + size - 1;
            return make_pair(a, b);
        }
    }
    cout << "rand_gen fail\n";
    return make_pair(0, 0);

}
int rand_gen(int min, int max)
{
// uniform distribution
    std::random_device rd;  // a seed source for the random number engine
    std::mt19937 gen(rd()); // mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(min, max); // generated by gen into an int in [a, b]
    return abs(distrib(gen));
// normal distribution
    
}
pair<int, int> find_min_max(vector<int> row)
{
    int min = INT_MAX, max = -1;
    for(auto i: row) {
        if(i > max) max = i;
        if(i < min) min = i;
    }
    return make_pair(min, max);
}

// ======================================================================
int main()
{
    // set<Key> tree;
    // tree_constructor(Maxlba, tree);

    // count keys
    // int N = ceil(log2(Maxlba+1) / log2(Kpp)) + 1;   // total level num
    // set<Key> collector;
    // for(int i = data_lba_begin; i <= data_lba_end; i ++) {
    //     key2root(i, i, N, collector);
    // }
    // collector.insert(Key(0, Maxlba, 1));    // insert root
    // // traverse(collector);
    // cout << "size: " << collector.size() << endl;

    // insert spec
    int reps, bar_width, bar_num;
    cout << "input Maxlba, Kpp, reps, bar_width, bar_num\n";
    cin >> Maxlba >> Kpp >> reps >> bar_width >> bar_num;

    if(Maxlba < 3) { 
        cout << "too small\n"; 
        return 0; 
    }

    int size_min = 0, size_max = bar_width;
    int N = ceil(log2(Maxlba+1) / log2(Kpp)) + 1;   // total level num

    vector<vector<int>> chart;
    for(int k = 0; k < bar_num; k ++) {
        vector<Record> result;
        vector<int> result_collector;
        for(int i = 0; i < reps; i ++) {
            // rand testcase
            int rand_size = rand_gen(size_min, size_max);
            pair<int, int> data = cmd_gen(rand_size);
            // collect keys
            set<Key> collector;
            for(int i = data.first; i <= data.second; i ++) {
                key2root(i, i, N, collector);
            }
            collector.insert(Key(0, Maxlba, 1));    // insert root
            // record
            result.push_back(Record(data.first, data.second, collector.size()));
            result_collector.push_back(collector.size());
            collector.clear();
        }
        size_min = size_max + 1;
        size_max += bar_width;
        chart.push_back(result_collector);
        result.clear();
    }
    // draw chart
    size_min = 0, size_max = bar_width;
    for(auto row: chart) {
        // cout << "[" << size_min << ", " << size_max << "]:  ";

        double sum = accumulate(begin(row), end(row), 0.0);
        double mean = sum/ row.size();
        pair<int, int> min_max = find_min_max(row);

        cout << mean << " " << min_max.first << " " << min_max.second << endl;

        size_min = size_max + 1;
        size_max += bar_width;
    }
    
    return 0;
}
